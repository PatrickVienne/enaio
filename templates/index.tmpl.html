<head>
  <style>
    body {
      margin: 0;
    }
  </style>

  <script src="//unpkg.com/three"></script>
  <!-- <script src="//unpkg.com/globe.gl"></script> -->
  <script src="https://unpkg.com/papaparse@5.3.1/papaparse.min.js"></script>
  <script src="//unpkg.com/three/examples/js/controls/TrackballControls.js"></script>
  <script src="//unpkg.com/three-globe"></script>
  <script src="//unpkg.com/solar-calculator"></script>
  <style>
    * {
      overflow: hidden;
      height: fit-content;
    }

    .hide {
      visibility: hidden;
    }

    .li:hover+.hide {
      visibility: visible;
      color: red;
    }
  </style>


</head>

<body>
  <div style="width: 100%; background-color: black; color: burlywood; text-align: center; position: fixed; top: 10px; margin-bottom: 10px;
  background: transparent;">
  <span>Trans-Border Energy Flows</span>
  </div>
  <div style="width: 100%; background-color: black; color: burlywood; text-align: center; position: fixed; bottom: 30px; margin-bottom: 10px;
  background: transparent;">
    <span><span id="time"></span><span>CET</span></span>
    <button id="playbtn" onclick="playpause()">Pause</button>
    <input type="range" id="curTime" name="curTime" min="0" max="9999999999999999" onchange="sliderChange()" disabled
      style="width: 50%;">
    <button id="reset" onclick="resetCamera()">ResetCamera</button>
  </div>
  <div style="width: 20%; background-color: black; color: burlywood; text-align: justify; position: fixed;
  background: transparent; margin-top: 50px;">
    <h4><span style="color: rgba(0, 255, 0, 0.9);">Im</span>/<span style="color: rgba(255, 0, 0, 0.9);">Export</span>
    </h4>
    <ul id="NetList" style="font-size: small;">
    </ul>
  </div>
  <div id="globeViz"></div>

  <script>

    // const populationFile = "/static/ne_110m_admin_0_countries.geojson";
    const populationFile = "/static/countries.geojson";

    const countriesFile = "/static/countries.json";
    const csvTransferFile = "/static/country_transfer.csv";
    const submarineCableFile = "//raw.githubusercontent.com/telegeography/www.submarinecablemap.com/master/web/public/api/v3/cable/cable-geo.json";


    let dtMultiplier = 1;
    let paused = false;
    function playpause() {
      if (paused) {
        dtMultiplier = 1
        paused = false;
        curTimeSld.disabled = true
        playbtn.innerText = "Pause"
      } else {
        dtMultiplier = 0
        paused = true;
        curTimeSld.disabled = false
        playbtn.innerText = "Play"
      }
    }

    resetCamera = () => { }

    function parseSubmarineCable(cablesGeo) {
      let cablePaths = [];
      cablesGeo.features.forEach(({ geometry, properties }) => {
        geometry.coordinates.forEach(coords => cablePaths.push({ coords, properties }));
      });
      return cablePaths;
    }

    function parseCountriesFile(values) {
      const countriesByCCA2 = new Map();
      const countriesByCCA3 = new Map();
      const latlngByCCA3 = new Map();
      const nameByCCA3 = new Map();

      values.forEach(country => {
        let name = country["name"]["common"];
        let cca2 = country["cca2"];
        let cca3 = country["cca3"];
        let latlng = country["latlng"];

        countriesByCCA2.set(cca2, country);
        countriesByCCA3.set(cca3, country);
        latlngByCCA3.set(cca3, latlng);
        nameByCCA3.set(cca3, name);
      });
      return { countriesByCCA2, countriesByCCA3, latlngByCCA3, nameByCCA3 };
    }

    function ParseTransferCSV(valuesLines) {
      let header = valuesLines[0]
      // console.log(header)
      // console.log(valuesLines.length)

      const countriesByCCA2 = new Map();
      const countriesByCCA3 = new Map();
      const latlngByCCA3 = new Map();
      const nameByCCA3 = new Map();

      const net_by_cca3 = new Map();
      // 0,00:00,01:00,Greece (GR),Albania (AL),Greece ,GR,Albania ,AL,184.0,0,1,"rgba(127, 127, 127, 0.8)",,"[39, 22]","[41, 20]",GRC,ALB
      let results = [];
      for (let i = 1; i < valuesLines.length; i++) {
        let start = valuesLines[i][1]
        let end = valuesLines[i][2]
        let value = (+valuesLines[i][9]) || 0;
        if (value === "NaN" || value === undefined || value === null) {
          value = 0;
        }
        let from_country_latlng = valuesLines[i][14]
        let to_country_latlng = valuesLines[i][15]
        let from_country_cca3 = valuesLines[i][16]
        let to_country_cca3 = valuesLines[i][17]
        if (net_by_cca3.has(from_country_cca3)) {
          let cca3_value = +net_by_cca3.get(from_country_cca3) || 0;
          if (cca3_value === "NaN" || cca3_value === undefined || cca3_value === null) {
            cca3_value = 0;
          }
          net_by_cca3.set(from_country_cca3, cca3_value + +value)
        } else {
          net_by_cca3.set(from_country_cca3, +value)
        }
        if (net_by_cca3.has(to_country_cca3)) {
          let cca3_value = +net_by_cca3.get(to_country_cca3) || 0;
          if (cca3_value === "NaN" || cca3_value === undefined || cca3_value === null) {
            cca3_value = 0;
          }
          net_by_cca3.set(to_country_cca3, cca3_value - (+value))
        } else {
          net_by_cca3.set(to_country_cca3, - (+value))
        }
        if (valuesLines[i][1] === "00:00" && end === "01:00") {
          results.push({ start, end, value, from_country_latlng, to_country_latlng, from_country_cca3, to_country_cca3 })
        }
      }
      return [results, net_by_cca3];
    }

    function countryTransferToArcData(countriesTransfer) {
      return countriesTransfer.map((value) => {
        v = JSON.parse(value.from_country_latlng)
        w = JSON.parse(value.to_country_latlng)
        let startlat = v[0]
        let startlng = v[1]
        let endLat = w[0]
        let endLng = w[1]
        result = {
          startLat: startlat,
          startLng: startlng,
          endLat: endLat,
          endLng: endLng,
          color: [`rgba(0, 255, 0, 0.9)`, `rgba(255, 0, 0, 0.9)`],
          stroke: value.value / 6000
        }
        return result
      })

    }

    function loadFlowsToArcData(flows) {
      // console.log("Start Proc", flows)
      let arcs = flows.map((value) => {
        // { "border": "CTY|10YHR-HEP------M!CTY_CTY|10YHR-HEP------M_CTY_CTY|10YBA-JPCC-----D",
        //  "date": "30.01.2022", "starttimestr": "00:00", "endtimestr": "01:00", 
        //  "starttime": 1643497200, "endtime": 1643500800, "startLat": 44, "startLong": 18, "endLat": 45.166668,
        //   "endLong": 15.5, "startCCA3": "BIH", "endCCA3": "HRV", "timeframe": "00:00-01:00", 
        //   "upstreamDirection": ["BA", "HR"], "downstreamDirection": ["HR", "BA"], "upstream": 0, "downstream": 305, "netStream": -305 }
        if (+value["netStream"] > 0) {
          result = {
            startLat: value["startLat"],
            startLng: value["startLong"],
            endLat: value["endLat"],
            endLng: value["endLong"],
            color: [`rgba(0, 255, 0, 0.9)`, `rgba(255, 0, 0, 0.9)`],
            stroke: +value["netStream"] / 4000
          }
        } else {
          result = {
            startLat: value["endLat"],
            startLng: value["endLong"],
            endLat: value["startLat"],
            endLng: value["startLong"],
            color: [`rgba(0, 255, 0, 0.9)`, `rgba(255, 0, 0, 0.9)`],
            stroke: -(+value["netStream"]) / 4000
          }
        }

        // console.log("loadFlowsToArcData", value["startCCA3"], value["endCCA3"], value);
        return result
      })
      // console.log("ARCS", arcs);
      return arcs
    }

    const k = 5.;
    function sigmoid(z) {
      return 1. / (1. + Math.exp(-z / k));
    }

    function loadCountryValue(valueByCountry, v) {
      let countrycode = v.properties.ISO_A3;
      if (countrycode === "-99") {
        // console.log("Countrycode RE", countrycode, v)
        countrycode = v.properties.WB_A3;
      }
      if (countrycode === "-99") {
        // console.log("Countrycode RERE", countrycode, v)
        countrycode = v.properties.SU_A3;
      }
      if (countrycode === "-99") {
        // console.log("Could not identify countrycode", v)
      }
      if (valueByCountry.has(countrycode)) {
        value = valueByCountry.get(countrycode)
      } else {
        // console.log("valueByCountry NOT FOUND", v.properties.ISO_A3, v, 0);
        return 0
      }
      return sigmoid(value / 1000.) / 50 + 0.001;
    }

    function loadPointsPerCountry(valueByCountry, latlngByCCA3) {
      let results = []
      for (const [cca3, value] of valueByCountry.entries()) {
        latlng = latlngByCCA3.get(cca3)
        results.push(
          {
            lat: latlng[0],
            lng: latlng[1],
            size: Math.sqrt(Math.abs(value) / 4000000),
            radius: Math.sqrt(Math.abs(value) / 100000),
            color: value > 0 ? 'rgba(0, 255, 0, 0.85)' : 'rgba(255, 0, 0, 0.85)'
          })
      }
      return results
    }

    function loadCountryColor(valueByCountry, v) {
      let countrycode = v.properties.ISO_A3;
      if (countrycode === "-99") {
        // console.log("Countrycode RE", countrycode, v)
        countrycode = v.properties.WB_A3;
      }
      if (countrycode === "-99") {
        // console.log("Countrycode RERE", countrycode, v)
        countrycode = v.properties.SU_A3;
      }
      if (countrycode === "-99") {
        // console.log("Could not identify countrycode", v)
      }
      if (valueByCountry.has(countrycode)) {
        value = valueByCountry.get(countrycode)
      } else {
        // console.log("valueByCountry NOT FOUND", v.properties.ISO_A3, v, 0);
        return 'rgba(0, 0, 0, 0.3)'
      }
      let val = sigmoid(value / 1000.)
      let color = 'rgba(' + Math.round(255 * (1 - val)) + ',' + Math.round(255 * val) + ', 0, 0.7)';
      // console.log("valueByCountry", countrycode, value, val, color);
      return color;
    }
    // add sun layer on top
    const VELOCITY = 6; // minutes per frame

    const sunPosAt = dt => {
      const day = new Date(+dt).setUTCHours(0, 0, 0, 0);
      const t = solar.century(dt);
      const longitude = (day - dt) / 864e5 * 360 - 180;
      return [longitude - solar.equationOfTime(t) / 4, solar.declination(t)];
    };


    let dt = (+(new Date()) - 24 * 3600 * 1000);
    const solarTile = { pos: sunPosAt(dt) };
    const timeEl = document.getElementById('time');
    const playbtn = document.getElementById('playbtn');
    const curTimeSld = document.getElementById('curTime');
    const resetBtn = document.getElementById('reset');
    const netList = document.getElementById('NetList');

    function sliderChange() {
      dt = +curTimeSld.value;
    }

    function updateNetList(valueByCountry) {
      netList.innerHTML = ""
      for (const [cca3, value] of valueByCountry.entries()) {
        let newLi = document.createElement("li");
        let txt = (" " + Math.round(value));
        txt = txt.padStart(10, " ");
        newLi.innerText = cca3 + " " + txt + " MW";
        newLi.style = "color: " + (value > 0 ? 'rgba(0, 255, 0, 0.85)' : 'rgba(255, 0, 0, 0.85)');
        netList.appendChild(newLi);
      }
    }

    Promise.all([
      fetch(submarineCableFile).then(r => r.json()).then(cablesGeo => parseSubmarineCable(cablesGeo)),
      fetch(countriesFile).then(r => r.json()).then(countries => parseCountriesFile(countries)),
      // fetch(csvTransferFile).then(r => r.text()).then(countriesTransfer => Papa.parse(countriesTransfer).data),
      fetch(populationFile).then(r => r.json()).then(population => population),
      fetch("/api/total").then(r => r.json()).then(r => r.data)
      // ]).then(([cablesGeo, countriesInfo, countriesTransfer, countries, { Flows, Net, CountryInfo }]) => {
      // ]).then(([cablesGeo, countriesInfo, countries, { Flows, Net, CountryInfo }]) => {#
    ]).then(([cablesGeo, { countriesByCCA2, countriesByCCA3, latlngByCCA3, nameByCCA3 }, countries, { Flows, Net, CountryInfo }]) => {
      const minTime = Math.min(...Object.keys(Net)) * 1000
      const maxTime = Math.max(...Object.keys(Net)) * 1000

      curTimeSld.max = maxTime
      curTimeSld.min = minTime

      let lastFlow = null;
      const FlowAt = (dt) => {
        let unixSeconds = Math.round(dt / 1000 / 3600) * 3600
        if (unixSeconds !== lastFlow && unixSeconds in Flows) {
          globe.arcsData(loadFlowsToArcData(Flows[unixSeconds]));
          // console.log("Flows", new Date(unixSeconds * 1000), Flows[unixSeconds]);
          lastFlow = unixSeconds;
        }
      }

      let lastNet = null;
      const NetAt = (dt) => {
        let unixSeconds = "" + Math.round(dt / 1000 / 3600) * 3600
        if (lastNet != unixSeconds && unixSeconds in Net) {
          // console.log("NET", new Date(unixSeconds * 1000), Net[unixSeconds]);
          let entriesMap = new Map(Object.entries(Net[unixSeconds]));
          globe.polygonCapColor((v) => loadCountryColor(entriesMap, v))

          // add bins displying countries energy usage
          globe.pointsData(loadPointsPerCountry(entriesMap, latlngByCCA3))
            .pointAltitude('size')
            .pointRadius('radius')
            .pointColor('color')
          lastNet = unixSeconds;
          updateNetList(entriesMap);
        }
      }


      // console.log("Flows, Net, CountryInfo", Flows, Net, CountryInfo);
      // console.log("countriesInfo", countriesInfo);
      // console.log("countries", countries);
      // console.log("countriesTransfer", countriesTransfer);
      // let results = ParseTransferCSV(countriesTransfer);
      // let parsed = results[0];
      // let valueByCountry = results[1];
      // console.log("Parsed countriesTransfer", parsed);
      // console.log("valueByCountry countriesTransfer", valueByCountry);
      // let arcsData = countryTransferToArcData(parsed);
      // console.log("Parsed arcData", arcsData);

      const globe = new ThreeGlobe()
        .tilesData([solarTile])
        .tileLng(d => d.pos[0])
        .tileLat(d => d.pos[1])
        .tileAltitude(0.005)
        .tileWidth(180)
        .tileHeight(180)
        .tileUseGlobeProjection(false)
        .tileMaterial(() => new THREE.MeshLambertMaterial({ color: '#ffff00', opacity: 0.1, transparent: true }))
        .tilesTransitionDuration(0)

        .globeImageUrl('//unpkg.com/three-globe/example/img/earth-dark.jpg')
        .polygonsData(countries.features.filter(d => d.properties.code !== 'AQ'))
        .polygonSideColor(() => 'rgba(0, 0, 0, 1)')
        .polygonStrokeColor(() => '#111')
        // .polygonLabel(({ properties: d }) => `
        //   <b>${d.ADMIN} (${d.ISO_A2}):</b> <br />
        //   GDP: <i>${d.GDP_MD_EST}</i> M$<br/>
        //   Population: <i>${d.POP_EST}</i>
        // `)
        // .onPolygonHover(hoverD => Globe
        //   .polygonAltitude(d => d === hoverD ? 0.12 : 0.06)
        //   .polygonCapColor(d => d === hoverD ? 'steelblue' : colorScale(getVal(d)))
        // )
        .polygonsTransitionDuration(1000)




        // add lines transporting energy between countries
        .arcsData([])
        .arcColor('color')
        .arcStroke('stroke')
        .arcDashLength(0.4)
        .arcAltitude(0.05)
        .arcDashGap(0.08)
        .arcDashInitialGap(() => Math.random())
        .arcDashAnimateTime(700)
        .arcsTransitionDuration(0);

      globe
        .pathsData(cablesGeo)
        .pathPoints('coords')
        .pathPointLat(p => p[1])
        .pathPointLng(p => p[0])
        .pathColor(path => path.properties.color)
        // .pathLabel(path => path.properties.name)
        .pathDashLength(0.1)
        .pathDashGap(0.008)
        .pathDashAnimateTime(12000);


      // animate time of day
      let passedSeconds = 0;
      requestAnimationFrame(() =>
        (function animate() {
          // dt += VELOCITY * 60 * 1000;
          dt += VELOCITY * 60 * 10 * dtMultiplier;
          if (dt > maxTime) {
            dt = minTime
          } else if (dt < minTime) {
            dt = minTime
          }
          solarTile.pos = sunPosAt(dt);
          FlowAt(dt)
          NetAt(dt)
          globe.tilesData([solarTile]);
          timeEl.textContent = new Date(dt).toLocaleString();
          curTimeSld.value = dt
          requestAnimationFrame(animate);
        })()
      );


      // setTimeout(() => globe.polygonAltitude((v) => loadCountryValue(valueByCountry, v)), 1000);
      // setTimeout(() => globe.polygonCapColor((v) => loadCountryColor(valueByCountry, v)), 1000);


      // Setup renderer
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('globeViz').appendChild(renderer.domElement);

      // Setup scene
      const scene = new THREE.Scene();
      scene.add(globe);
      scene.add(new THREE.AmbientLight(0xbbbbbb));
      scene.add(new THREE.DirectionalLight(0xffffff, 0.6));

      // Setup camera
      const camera = new THREE.PerspectiveCamera();
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      camera.position.x = 20;
      camera.position.y = 150;
      camera.position.z = 100;

      // Add camera controls
      const tbControls = new THREE.TrackballControls(camera, renderer.domElement);
      tbControls.minDistance = 150;
      tbControls.rotateSpeed = 1;
      tbControls.zoomSpeed = 0.4;

      resetBtn.addEventListener("click", () => tbControls.reset());

      // Kick-off renderer
      (function animate() { // IIFE
        // Frame cycle
        tbControls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      })();
    });
  </script>
</body>